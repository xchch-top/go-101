go语言的设计哲学:简单,显式,组合,并发,面向工程.

go env
    https://static001.geekbang.org/resource/image/ba/96/ba6990798fb17fc18386749f9cce2c96.jpg
go help environment

go源文件总是用全小写字母形式的短小单词命名, 并且以.go扩展名结尾, 例如helloworld.go
整个go程序中仅允许有一个main包
go是一种编译型语言, 意味着, 只有你编译完go程序后, 才可以将生成的可执行文件交付与其他人, 并运行在没有安装go的环境中
go代码风格使用Tab而不是空格来实现缩进, go源码文件本身采用的是Unicode字符集, 而且用的是UTF-8标准的字符编码方式

在go 1.16版本中, go module已经成为了go默认的包依赖管理机制和go源码构建机制. go module的核心是一个名为go.mod的文件, 文件中存储了module对第三方依赖的全部信息
go.sum记录了直接依赖和间接依赖的版本的hash, 用来校验本地宝的真实性, 在构建的时候, 如果本地依赖包的hash值和go.sum中记录的不一致, 会被拒绝构建
go程序的构建过程就是确定包版本, 编译以及将编译后的目标文件链接在一起的过程

添加go mod文件 go mod init gitlab.xchch.top/zhangsai/go-101
手动添加依赖 go get github.com/valyala/fasthttp
工具自动添加依赖 go mod tidy
go mod tidy 下载的依赖module会放在本地的module缓存路径下, 变量值为$GOPATH[0]/pkg/mod, go1.15后可以通过GOMODCACHE环境变量自定义本地module的缓存路径

go module的最小版本使用原则: A明明说只要求C v1.1.0, B明明说只要求C v1.3.0, go会在改项目依赖的所有版本中, 选出符合项目整体需求的最小版本
go团队认为最小版本选择, 为go程序实现持久的和可重现的构建提供了最佳的方案

go语言要求可执行程序的main包必须包含main函数, 否则go编译器会报错. 在启动了多个goroutine的go应用中, main.main函数将在go应用的主goroutine中执行
非main包中的go函数仅限于包内使用

对于init函数, go程序中我们不能显式的调用init, 否则会受收到编译错误
go包可以拥有不止一个init函数, 每个组成go包的go源文件中, 可以定义多个init函数.
在初始化go包的时候, go会按照一定的次序, 逐一地调用这个包的init函数, 一般来说, 先传递给go编译器的源文件中的init函数, 会先被执行, 同一个源文件中的多个init函数, 会按照声明依次执行
根据go语言规范, 一个被多个包依赖的包仅会被初始化了一次, 包内按照 "常量 -> 变量 -> init函数"的顺序进行初始化

从程序逻辑结构角度来看, go包是程序逻辑封装的基本单元, 每个包都可以理解为是一个自治的封装良好的, 对外暴露有限接口的基本单元.

init函数的第一个常用用途: 重置包级变量值. 负责对包内部以及暴露到外部的包级数据(主要是包级变量)的初始状态进行检查
init函数的第二个常用用途: 实现对包级变量的复杂初始化
init函数的第三个常用用途: 在init函数中实现"注册模式"

go语言变量初始为类型零值
go语言类型零值 https://static001.geekbang.org/resource/image/92/23/92242134ff5ccdaed32854d01690ab23.jpg

go语言的变量分为两类, 包级变量和局部变量
包级变量就是包级别可见的变量. 如果是导出变量, 那么这个包级变量也可以被视为全局变量
局部变量就是go函数或方法体内声明的变量, 尽在函数或方法体内可见,

go语言预定义标识符 https://static001.geekbang.org/resource/image/01/95/01b8135e83c9fc39afcecdb26d4e1495.jpg
go vet工具可以用于对go源码做一系列静态检查

go语言原生支持的数值类型包含整型, 浮点型以及复数类型

go字符串中的每个字符都是一个Unicode字符, 并且这些Unicode字符是以UTF-8格式存储在内存当中的.
go字符串组成的两种视角: 字节视角、字符视角

rune本质上是int32类型的别名类型, type rune = int32
一个rune实例就是一个Unicode字符, 一个Go字符串也可以被视为rune实例的集合

utf-32编码方案固定使用4个字节表示每个Unicode字符码点
utf-8方案采用边长字节, 对Unicode字符的码点进行编码, utf-8编码使用的字节数量从1个到4个不等. 

StringHeader是一个string的运行时表示, 由一个指向底层存储的指针和字符串的长度类型组成

字符串的 +/+= 操作性能不高, go还提供了strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作
在字符串比较上, go采用字典序的比较策略, 分别从每个字符串的起始处, 开始逐个字节地对两个字符串类型变量进行比较,当两个字符串之间出现了第一个不同的元素, 比较就结束了.

go支持字符串与字节切片, 字符串与rune切片的双向转换, 并且这种转换无需调用任何函数, 只需使用显式类型转换就可以了

隐式转换说的是, 对于无类型常量参与的表达式求值, go编译器会根据上下文中的类型信息, 把无类型常量自动转换为对应的类型后, 再参与求值计算.
无类型常量与常量隐式转型的珠联璧合, 使得在go这样的具有强类型系统的语言, 在处理表达式混合数据类型运算的时候具有比较大的灵活性, 代码编写也得到了一定程度的简化.

go语言其实并没有原生提供枚举类型, go语言中, 可以使用const代码块定义的常量集合, 来实现枚举. 枚举类型本质上就是一个由有限数量常量构成的集合.

