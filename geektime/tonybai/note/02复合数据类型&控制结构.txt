go语言原生内置了多种复合数据类型, 包括数组, 切片, map, 结构体, channel.

go提供了预定义函数len可以用于获取一个数组类型变量的容量, 通过unsafe包提供的Sizeof函数, 可以获得一个数组变量的占用字节数

go切片在运行时其实就是一个三元组结构: array len cap

切片的自动扩容: 当通过append操作向切片追加数据的时候, 如果这时切片的len和cap的值是相等的, 就是说切片底层数组已经没有空闲空间来存储追加的值了, go运行时就会对这个切片做扩容操作, 来保证切片始终能存储下追加的新值.

切片的自动扩容会导致切片与数组的关系解绑. 重新扩容实际上是重新分配内存产生一个新的数组, 所以尽量不要修改输入的切片, 减少副作用.

map类型对key的类型有严格要求, 因为map类型要保证key的唯一性, go语言中要求 key的类型必须支持 == 和 != 两种比较操作符.

go语言中, 函数类型, map类型自身, 以及切片只支持与nil的比较, 不支持同类型两个变量的比较. 函数类型, map类型自身, 切片类型不能作为map的key类型.

和切片类型变量一样, 如果没有显式的赋予map变量初值, map类型变量的默认值为nil.
map类型不支持零值可用, 和切片一样, 为map类型变量显式赋值有两种方式: 一种是使用复合字面量, 一种是使用make这个预声明的内置函数.
    ① m := map[string]string{}
    ② m := make(map[string]string)

如果插入新键值对的时候, 某个key已经存在于map中了, 那插入操作就会用新值覆盖旧值.
map类型可以通过内置的len, 获取当前变量已经存储的键值对数量.

当尝试取获取一个键对应的值的时候, 如果键在map中不存在, 也会得到一个值, 这个值是value元素类型的零值.
go语言中, 请使用"comma ok"惯用法对map进行键查找和键值读取操作

对同一map做多次遍历的时候, 每次遍历元素的次序都不相同, 这是go语言map类型的一个重要特点, 程序逻辑千万不要依赖遍历map所得到的元素次序

和切片类型一样, map也是引用类型, map类型作为参数被传递给函数或方法的时候, 实际上传递的只是一个"描述符"

自定义新类型的两种方式
    类型定义: type t1 int
    使用类型别名: type Int=int

空结构体: type Empty struct{}
    空结构体类型变量的大小为0, 用途: 作为一种事件信息进行Goroutine之间的通信

不能在结构体T定义中, 拥有自身类型T定义的字段; 却可以拥有自身类型的指针类型, 以自身类型为元素类型的切片类型, 以及以自身类型为value的map类型的字段.

结构体类型的变量通常都要被赋予适当的初始值后, 才有合适的意义.

Go推荐用 field:value 形式的复合字面值, 对结构体类型变量显示初始化, 这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合, 这也是go语言惯用法.
复合字面值作为结构体类型变量被广泛使用, 即便结构体采用类型零值时, 我们也会使用复合字面值的形式, 而比较少使用new这一个Go预定义的函数来创建结构体变量实例.

go结构体类型是将它的元素一个接一个以平铺形式, 存放在一个连续内存块中.
可以借助标准库unsafe包提供的函数, 获得结构体类型变量占用的内存大小, 以及它每个字段在内存中相对于结构体变量起始地址的偏移量.

内存对齐: 

在日常编码中要减少多分支结构, 甚至是二分支的使用, 这会有助于我们写出优雅、简洁、易读易维护且不易错的代码.

经典for循环语句有四个组成部分: 循环前置语句, 循环控制条件, 循环后置语句, 循环体

for range对于string类型来说, 每次循环得到的v值都是一个Unicode字符码点, 也就是rune类型, 而不是一个字节
for的经典形式与使用for range形式, 对string类型进行循环操作的语义是不同的.

对map进行循环操作, for range是唯一的方法, for经典循环形式是不支持对map类型变量进行 循环控制的