sync/atomic包实现了同步算法底层的原子的内存操作原语, 我们把它叫作原子操作原语, 它提供了一些实现原子操作的方法
原子操作: 一个原子在执行的时候, 其他线程不会看到执行一般的操作结构. 在其它线程看来, 原子操作要么执行完了, 要摸还没有执行.
cpu提供了基础的原子操作, 不过, 不同架构的系统的原子操作是不一样的
go提供了一个通用的原子操作API, 将更底层的不同架构下的实现封装成atomic包, 提供了修改类型的原子操作和加载存储类型的原子操作的API

atomic操作的对象是一个地址, 你需要把可寻址的变量的地址作为参数传递给方法, 而不是把变量的值传递给方法

atomic提供的方法
Add: 给第一个参数地址中的值增加一个delta值
CAS: 比较当前addr地址里的值是不是old, 如果不等于old, 就返回false, 如果等于old, 就把此地址的值替换成new值, 返回true
Swap: 不需要比较旧值, 只是粗暴地替换, 替换后还可以返回旧值
Load: 取出addr地址中的值
    即使在多处理器, 多核, 有CPU cache的情况下, 这个操作也能保证Load是一个原子操作
Store: 把一个值存入到指定的addr地址中
    即使在多处理器, 多核, 有CPU cache的情况下, 这个操作也能保证Store是一个原子操作. 别的goroutine通过Load读取出来, 不会看到存取了一半的值

Value类型: 只有Store/Load方法

第三方库的扩展
https://github.com/uber-go/atomic 提供了面向对象的使用方式, 定义和封装了几种与常见类型相对应的原子类型的操作, 这些类型提供了原子操作的方法

内存屏障
一个写内存屏障会告诉处理器, 必须等到它管道中的未完成的操作(特别是写操作)都被刷新到内存中, 再进行操作. 此操作还会让相关的处理器CPU缓存失效, 以便让它们从主存中拉取最新的值
atomic包提供的方法会提供内存屏障的功能, 所以, atomic不仅仅可以保证赋值的数据完整性, 还能保证数据的可见性, 一旦一个核更新了该地址的值, 其他处理器总是能读取到最新值
因为需要处理器之间保证数据的一致性, atomic的操作其实也是会降低性能的

代码演示
c12_v1: Value类型的使用
c12_v2: Lock-Free Queue实现