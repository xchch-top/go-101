## 函数

函数是唯一一种基于特定输入, 实现特定任务并可返回任务执行结果的代码块
go函数的声明由5部分组成, 关键字func, 函数名, 参数列表, 返回值列表, 函数体.

参数列表和返回值列表的组合被称为函数签名, 它是决定两个函数类型是否相同的决定因素. 函数类型也可以看成是由func关键字与函数签名组合而成.
如果两个函数类型的函数签名是相同的, 即便参数列表中的参数名, 以及返回值列表中的返回值变量名都是不同的, 这两个函数类型也是相同的类型.
func (a int, b string) (results []string, err error) 和 func (c int, d string) (sl []string, err error) 的函数类型是 func (int, string) ([]string, error)
结论: 每个函数声明所定义的函数, 仅仅是对应的函数类型的一个实例.

T{}被称为复合类型字面值, func(){}叫做函数字面值, 函数字面值由函数类型和函数体组成, 也称为匿名函数, 匿名函数在Go中用途很广.

函数声明阶段, 我们把参数列表中的参数叫做形式参数(Parameter 简称形参), 在函数体中, 我们使用的都是形参
函数实际调用时传入的参数称为实际参数(Argument 简称实参)

go语言中, 函数参数传递采用的是值传递.
值传递就是将实际参数在内存中的表示逐位拷贝到形参列表中. 值传递拷贝的就是他们自身, 传递的开销也与他们自身的大小成正比.
整形、数组、结构体这类类型, 他们的内存表示就是他们自身的数据内容; string、切片、map这些类型, 内存表示对应的是他们数据内容的"描述符".
只拷贝描述符的拷贝方式, 也被称为浅拷贝.

对于类型为接口类型的形参，Go编译器会把传递的实参赋值给对应的接口类型形参；
对于为变长参数的形参，Go编译器会将零个或多个实参按一定形式转换为对应的变长形参
在go中, 变长参数实际上是通过切片来实现的.

go函数支持多返回值, go语言的错误处理机制很大程度就是建立在多返回值的机制之上的
go标准库以及大多数项目的代码中, 都选择了使用普通的非具名返回值形式

函数是一等公民 http://wiki.c2.com//?FirstClass
1. go函数可以存储在变量中
2. 支持在函数内创建并通过返回值返回
3. 作为参数传入函数
4. 拥有自己的类型

代码演示
func/c21_v1: 函数是一等公民

闭包:
闭包的本质就是一个匿名函数或者叫函数字面值, 它们可以引用它的包裹函数, 也就是创建它们的函数中定义的变量.
然后, 这些变量在包裹函数和匿名函数之间共享, 只要闭包可以访问, 这些共享变量就会继续存在.

函数是一等公民的应用:
①函数可以被显式转型
②利用闭包简化函数调用

代码演示
func/c21_v2: 函数是一等公民的应用

## 错误处理

go函数增加了多返回值机制, 来支持错误状态和返回信息的分离, 并建议开发者把要返回给调用者的信息和错误状态标识, 分别放在不同的返回值中
go语言惯用法, 使用error这个接口类型表示错误, 通常将error类型返回值放在返回值列表的末尾, 就像fmt.Fprintf函数声明中那样

在标准库中提供了两种方便go开发者构造错误值的方法: errors.New和fmt.Errorf
    err := errors.New("your first demo error")
    errWithCtx = fmt.Errorf("index %d is out of bounds", i)
这两种方法实际上返回的是同一个实现了error接口的类型的实例, 这个未导出类型就是errors.errorString

通过断言类型, 我们可以判断接口类型的动态类型, 以及获取它动态类型的值

error类型的三个好处 ①统一了错误类型 ②错误是值 ③易扩展, 支持自定义错误上下文
error接口是错误值提供者与错误值的检视者之间的契约, error接口的实现者负责提供错误上下文, 供负责错误处理的代码使用.
这种错误具体上下文与作为错误值类型的error接口类型解耦, 体现了go组合设计哲学中'正交'的理念

四种错误处理的惯用策略
透明错误处理策略
    最简单的错误策略莫过于完全不关心返回错误值携带的上下文信息, 只要发生错误就进入唯一的错误处理执行路径.
    这也是go语言中最常见的错误处理策略, 由于错误处理方并不关心错误值的上下文, 所以可以直接使用go标准库提供的两个基本错误值构造方法来构造错误值
哨兵错误处理策略
    当错误处理方不能只根据'透明的错误值'就做出错误处理路径选取的情况下, 错误处理方式会尝试对返回的错误值进行检视
    哨兵错误值变量以 ErrXXX 格式命名, 哨兵策略让错误处理方在检视错误值的时候, 可以有的放矢
    建议尽量使用errors.Is方法去检视某个错误值是否就是某个预期错误值, 或者包装了某个特定的哨兵错误值
错误值类型检视策略
    尽量使用errors.As方法去检视某个错误值是否是某自定义错误类型的实例
错误行为特征检视策略
    将某个包中的错误类型归类, 统一提取出一些公共的错误行为特征, 并将这些错误行为特征放入一个公开的接口类型中.

go1.13开始, 标准库errors包提供了Is函数用于错误处理方对错误值的检视, Is函数类似于把一个error类型变量与哨兵错误值进行比较
go1.13开始, 标准库errors包提供了As函数给错误处理方检视错误值, As函数类似于通过类型断言判断一个error类型是否为特定的自定义错误类型

在错误处理策略选择上, 建议
①尽量使用'透明错误'处理策略, 降低错误处理方与错误值构造方之间的耦合
②如果可以通过错误值类型的特征进行错误检视, 那么请尽量使用"错误行为特征检视策略"
③在上述两种策略无法实施的情况下, 再使用"哨兵策略"和"错误值类型检视策略"
④尽量使用errors.Is和errors.As函数替换原先的错误检视比较语句

## panic

健壮的函数意味着, 无论调用者如何使用你的函数, 你的函数都能以合理的方式处理调用者的任何输入, 并给调用者返回预设的, 清晰的错误值.
简洁优雅, 则意味着函数的实现易读, 易理解, 同时简洁也意味着统计意义上的更少的bug.

健壮性的三不要原则: ①不要相信任何外部输入的参数 ②不要忽略任何一个错误 ③不要假定异常不会发生

go语言中的异常 - panic
panic指的是程序在运行时出现的一个异常情况. 如果异常出现了, 但没有捕获并恢复, go程序的执行就会被终止, 即便出现异常的位置不在主Goroutine中也会是这样.
无论在哪个goroutine中发生未被恢复的panic, 整个程序都将崩溃退出
当函数F调用panic函数时, 函数F的执行将停止. 不过函数F中已进行的deferred函数都会正常执行, 执行完这些deferred函数后, 函数F才会把控制权返还给其调用者

recover
recover是go内置的专门用于恢复panic的函数, 它必须被放在一个defer函数中才生效
如果recover捕捉到panic, 它就会返回以panic的具体内容为错误上下文信息的错误值, 如果没有panic发生, 那么recover将返回nil
如果panic被recover捕捉到, panic引发的panicking过程就会停止

代码演示
panic/c23_v1: panic & recover

如何应对panic
① 评估程序对panic的忍受度: 对于局部不影响整体的异常处理策略, 捕获和恢复panic的位置通常都在子goroutine的起始处
② 提示潜在的bug: 大多数panic的使用都是充当类似断言的作用
③ 不要混淆异常与错误: 不要将panic当做错误返回给api调用者

defer是go语言提供的一种延迟调用机制, defer的运作离不开函数
带有defer的函数执行开销, 仅是不带有defer的函数的执行开销的1.45倍左右, 已经达到了几乎可以忽略不计的成都, 我们可以放心使用

## 方法

go中方法都必须是归属于一个类型的, 而receiver参数的类型就是这个方法归属的类型
receiver参数的基类型本身不能为指针类型或接口类型
代码演示 method/c24_v1: receiver参数的基类型本身不能为指针类型或接口类型

go要求, 方法声明要与receiver参数的基类型声明放在同一个包内
基于这个约束, 可以得到两个推论 ①我们不能为原生类型添加方法 ②不能跨越go包为其他包的类型声明新方法

go语言中的方法的本质就是: 一个以方法的receiver参数作为第一个参数的普通函数
代码演示
method/c24_v2: 方法的本质
method/c24_v3: 方法的本质

## 方法集合

方法采用类型为T的receiver参数时, 代表T类型实例的receiver参数以值传递方式传递到方法体中, 实际上是T类型实例的副本
方法采用类型为*T的receiver参数时, 代表*T类型实例的receiver参数以值传递方式传递到方法体中, 实际上是T类型实例的地址

无论是T类型实例还是*T类型实例, 都既可以调用receiver为T类型的方法, 也可以调用receiver为*T类型的方法.

选择receiver参数类型的三个原则
①如果要把对receiver参数代表的类型实例的修改, 反映到原类型实例上, 那么我们应该选择*T作为receiver参数的类型
②如果不需要在方法中对类型实例进行修改, 通常会为receiver选择T类型, 这样可以缩窄外部修改类型实例内部状态的接触面
③T类型是否需要实现某个接口:
    如果T类型需要实现某个接口, 那我们就要使用T作为receiver类型的参数, 来满足接口类型方法集合中的所有方法
    如果T不需要实现某一接口, 但*T需要实现该接口, 那么根据方法集合概念, *T的方法集合是包含T的方法集合的, 这样我们在确定Go方法的receiver类型时, 参考原则一和原则二就可以了
前面两个原则更多聚焦于类型内部, 第三个原则则更多从全局的设计层面考虑, 聚焦于这个类型接口与接口类型间的耦合关系

方法集合
方法集合是用来判断一个类型是否实现了某一接口类型的唯一手段, 也可以说, 方法集合决定了接口实现
代码演示 method/c25_v1

go中任何一个类型都有属于自己的方法集合, 或者方法集合是go类型的一个属性, 单不是所有类型都有自己的方法
比如int类型就没有自己的方法, 所以对于没有定义方法的go类型, 称其拥有空方法集合
*T类型的方法集合包含所有以*T为receiver参数类型的方法, 以及所有以T为receiver参数类型的方法
接口类型相对特殊, 它只会列出代表接口的方法列表, 不会具体定义某个方法, 它的方法集合就是他方法列表中的所有方法
代码演示 method/c25_v2

方法集合决定接口实现的含义是:
如果某类型T的方法集合与某接口类型的方法集合相同, 或者类型T的方法集合是接口类型I方法集合的超集, 那么我们就说这个类型T实现了接口I

## 类型嵌入

go支持两种类型嵌入, 分别是接口类型的类型嵌入和结构体类型的类型嵌入

接口类型的类型嵌入
接口类型嵌入的语义就是新接口类型将嵌入的接口类型的方法集合, 并入到自己的方法集合中
go1.14之前, 如果新接口类型嵌入了多个接口类型, 这些嵌入的接口类型的方法集合不能有交集, 同时嵌入的接口类型的方法集合中的方法名字, 不能与新接口中的其他方法同名.
go1.17之后没有了这个限制
代码演示 type_embed/c26_v1

以某个类型名, 类型的指针类型名或接口类型名, 直接作为结构体字段的方式就叫做结构体的类型嵌入, 这些字段也被叫做嵌入字段(Embedded Field)
嵌入字段的可见性与嵌入字段的类型的可见性是一致的, 如果嵌入类型的名字是首字母大写的, 那么也就是说明这个嵌入字段是可导出的
代码演示 type_embed/c26_v2

go语言中, 嵌入字段类型的底层类型不能是指针类型, 而且, 嵌入字段的名字在结构体定义也必须是惟一的

类型嵌入这种看似继承的机制, 实际上是一种组合的思想, 更具体点, 它是一种组合中的代理模式
结构体类型中嵌入接口类型
结构体类型的方法集合, 包含嵌入的接口类型的方法集合
代码演示 type_embed/c26_v3
当结构体嵌入的多个接口类型的方法集合存在交集时, 编译器会报错
代码演示 type_embed/c26_v4
嵌入某接口类型的结构体类型的方法集合中包含了这个接口类型的方法集合, 意味着, 这个结构体类型也是它嵌入的接口类型的一个实现
代码演示 type_embed/c26_v5
结构体中嵌入结构体类型, 外部的结构体类型T可以继承嵌入的结构体类型的所有的方法的实现.
    无论是T类型的变量实例还是*T类型变量实例, 都可以调用所有继承的方法. 问题是带有嵌入类型的新类型究竟继承了哪些方法

defined类型与alias类型的方法集合 ???
无论原类型是接口类型还是非接口类型, 类型别名都与原类型又有相同的方法集合
