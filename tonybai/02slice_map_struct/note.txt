## 数组

go语言原生内置了多种复合数据类型, 包括数组, 切片, map, 结构体, channel.

go语言的数组是一个长度固定的, 由同构类型元素组成的连续序列
数组类型变量的声明 var arr [N]T
如果两个数组类型的元素类型T与数组长度N都是一样的, 那么这两个数组类型是等价的

go提供了预定义函数len可以用于获取一个数组类型变量的容量, 通过unsafe包提供的Sizeof函数, 可以获得一个数组变量的占用字节数
64位平台上, int类型的大小为8, 不进行显式初始化, 那么数组中的元素值就是它类型的零值
数组下标是从0开始的, 如果下标值超出数组长度范畴, 或者是负数, 编译器会给出错误提示

代码演示:
slice/c15_v1: 数组类型

## 切片

数组在使用上有两点不足: 固定的元素个数, 传值机制导致的开销大
声明并初始化一个切片变量 var nums = []int{1, 2, 3, 4, 5, 6}
与数组的声明相比, 切片声明仅仅是少了一个长度属性, 切片的长度不是固定的, 而是随着切片中元素个数的变化而变化的

go切片在运行时其实就是一个三元组结构: array len cap

切片的自动扩容: 当通过append操作向切片追加数据的时候, 如果这时切片的len和cap的值是相等的, 就是说切片底层数组
    已经没有空闲空间来存储追加的值了, go运行时就会对这个切片做扩容操作, 来保证切片始终能存储下追加的新值.
切片的自动扩容会导致切片与数组的关系解绑. 重新扩容实际上是重新分配内存产生一个新的数组.

初值为nil的切片类型变量, 可以借助内置的append的函数进行操作, 这种在go语言中被称为零值可用

## map

map类型对key的类型有严格要求, 因为map类型要保证key的唯一性, key的类型必须支持 == 和 != 两种比较操作符. value元素的类型可以是任意的
函数类型, map类型自身, 以及切片只支持与nil的比较, 不支持同类型两个变量的比较. 所以, 函数类型, map类型自身, 切片类型不能作为map的key类型.

声明一个map变量 var m map[string]int
和切片类型变量一样, 如果没有显式的赋予map变量初值, map类型变量的默认值为nil.
map类型不支持零值可用, 和切片一样, 为map类型变量显式赋值有两种方式: 一种是使用复合字面量, 一种是使用make这个预声明的内置函数.
    ① 使用复合字面量 m := map[string]string{}
    ② 使用make m := make(map[string]string)

代码演示:
map/c16_v1: map的定义

map的基本操作
插入新键值对:
    我们不需要自己判断数据有没有插入成功, 因为go会保证插入总是成功的
    如果插入新键值对的时候, 某个key已经存在于map中了, 那插入操作就会用新值覆盖旧值.
获取键值对数量:
    map类型可以通过内置的len, 获取当前变量已经存储的键值对数量.
    我们不能通过map类型变量调用cap, 获取当前容量
查找:
    判断某个key是否存在于某个map中
    当尝试取获取一个键对应的值的时候, 如果键在map中不存在, 也会得到一个值, 这个值是value元素类型的零值.
    go语言中, 请使用"comma ok"惯用法对map进行键查找和键值读取操作 v, ok := m["key1"]
删除:
    delete函数是从map中删除键的唯一方法
遍历map中的键值数据
    遍历map只有一种方法: 就是for range
    对同一map做多次遍历的时候, 每次遍历元素的次序都不相同, 这是go语言map类型的一个重要特点, 程序逻辑千万不要依赖遍历map所得到的元素次序

和切片类型一样, map也是引用类型, map类型作为参数被传递给函数或方法的时候, 实际上传递的只是一个"描述符"
当map变量被传递到函数或方法内部后, 我们在函数内部对map类型参数的修改在函数外部也是可见的
考虑到map可以自动扩容, map中元素的value位置可能在这一过程中发生变化, 所以go不允许获取map中value的地址

map实例不是并发安全的, 也不支持并发读写
go1.9版本中引入了支持并发写安全的sync.Map类型, 可以在并发读写的场景下替换掉map

代码演示:
map/c16_v2: map并发读写的异常场景

## 结构体

自定义新类型的两种方式
类型定义: type t1 int --> 基于int定义的新自定义类型
    本质上相同的两个类型, 它们的变量可以通过显式转型进行相互赋值,本质上是不同的两个类型, 它们的变量连显式转型都不可能, 更不要说相互赋值了
使用类型别名: type Int=int
    类型别名并没有定义出新类型, Int和int实际上就是同一种类型

空结构体: type Empty struct{}
空结构体类型变量的大小unsafe.Sizeof(struct{})为0
用途: 作为一种事件信息进行Goroutine之间的通信, 这种以空结构体为元素类建立的channel, 是目前能实现的, 占用内存最小的goroutine间通信方式

go不支持在结构体类型定义中, 递归地放入其自身类型字段的定义方式
可以在结构体中定义自身类型的指针类型, 以自身类型为元素类型的切片类型, 以及以自身类型为value的map类型的字段

代码演示:
struct/c17_v1: 结构体定义, 嵌入类型

结构体类型的变量通常都要被赋予适当的初始值后, 才有合适的意义.
go结构体类型由若干字段组成, 当这个结构体类型变量的各个字段的值都是零值时, 我们就说这个结构体变量处于零值状态
var book Book: 一本书没有署名, 作者, 页数, 索引, 通过Book类型对这本书的抽象就失去了实际价值

零值可用
如果一种类型采用零值初始化得到的零值变量, 是有意义的, 而且是直接可用的, 称这种类型为零值可用类型.
定义零值可用类型是简化代码, 改善开发者使用体验的一种重要的手段
go标准库中零值可用的例子: sync.Mutex

复合字面值
go推荐用 field:value 形式的复合字面值, 对结构体类型变量显示初始化, 这种方式可以降低结构体类型使用者和结构体类型设计者之间的耦合, 这也是go语言惯用法.
复合字面值作为结构体类型变量被广泛使用, 即便结构体采用类型零值时, 我们也会使用复合字面值的形式, 而比较少使用new这一个Go预定义的函数来创建结构体变量实例.

go结构体类型是将它的元素一个接一个以平铺形式, 存放在一个连续内存块中.
可以借助标准库unsafe包提供的函数, 获得结构体类型变量占用的内存大小, 以及它每个字段在内存中相对于结构体变量起始地址的偏移量.

内存对齐