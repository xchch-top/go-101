## 并发

go语言的设计目标之一: 面向多核, 原生支持并发

并发和并行
并行: 在同一时刻, 有两个或两个以上的任务的代码在处理器上执行. 从概念里我们知道, 多个处理器或多核处理器是并行执行的必要条件
将程序分成多个可独立执行的部分的结构化程序的设计方法, 是并发设计. 采用了并发设计的应用可以看成是一组独立执行的模块的组合

进程的'包袱'太重, 导致它的创建, 切换与撤销的代价都很大. 于是线程遍走入了人们的视野, 线程就是运行于线程上下文中的更轻量的执行流
基于线程的应用通常采用单进程多线程的模型, 一个应用对应一个进程, 应用通过并发设计将自己划分为多个模块, 每个模块由一个线程独立承载执行
多个线程共享这个进程所拥有的资源, 但线程作为执行单元可被独立调度到处理器上执行
在不满足并行必要条件的情况下, 即便是采用和并发设计的程序, 依旧不可以并行执行.
在多核处理器称为主流的时代, 即便采用并发设计的应用程序以单实例的方式运行, 其中的每个内部模块都是运行在一个独立的线程中, 多核资源得到充分利用
并发让并行变得更加容易, 采用并发设计的应用可以将负载自然扩展到各个CPU核上, 从而提升处理器的利用效率

## goroutine

go实现了goroutine这一由go运行时(runtime)负责调度的, 轻量级的用户级线程, 为并发程序设计提供原生支持
go语言管理是优先考虑并发设计, 这样做的目的更多时考虑随着外界环境的变化, 通过并发设计的go应用可以更好地, 更自然地适应规模化

goroutine的主要优势
①资源占用小, 每个goroutine的初始栈大小仅为2k
②由go运行时而不是操作系统调度, goroutine上下文切换是在用户层完成, 开销更小
③在语言层面而不是通过标准库提供, goroutine由go关键字创建, 一退出就会被回收或者销毁, 开发体验更佳
④语言内置channel作为goroutine间通信原语, 为并发设计提供了强大支持

通过go关键字, 我们可以基于已有的具名函数/方法创建goroutine, 也可以基于匿名函数/闭包创建goroutine
创建goroutine之后, go关键字不会返回goroutine id之类的唯一标识goroutine的id
一个应用内部启动的所有goroutine共享进程空间的资源, 如果多个goroutine访问同一块内存数据, 将会存在竞争, 我们需要进行goroutine间的同步
goroutine的执行函数的返回, 就意味着goroutine退出. 如果main goroutine退出了, 也就意味着整个应用程序的退出
goroutine执行的函数或方法即便有返回值, go也会忽略这些返回值, 如果你要获取goroutine执行后的返回值, 可以通过goroutine间通讯来实现.

## channel

go语言的CSP模型的实现包含两个重要组成部分
一个是goroutine, 它是go应用并发设计的基本构建和执行单元
另一个就是channel, channel既可以用来实现goroutine间的通信, 还可以实现goroutine间的同步

go在语法层面将并发源语channel作为一等公民对待, 这意味这我们可以像使用普通变量那样使用channel

如果channel类型变量在声明时没有被赋值, 那么它的默认值是nil, 为channel类型变量赋初值的唯一方法就是使用make这个go预定义的函数
channel是用于goroutine间通信的, 绝大多数对channel的读写都被分别放在了不同的goroutine中
nil是chan的零值, 是一种特殊的chan, 对值是nil的chan的发送接收, 调用者总是会阻塞

由于无缓冲channel的运行时层实现不带有缓冲区, 所以goroutine对无缓冲channel的接收和发送操作是同步的.
对同一个无缓冲channel, 只有对它进行接收操作的goroutine和对它进行发送操作的goroutine都存在的情况下, 通信才能得以进行.
否则单方面的操作会让对应的goroutine陷入挂起状态.
代码演示 c33_v1

带缓冲区的运行时层实现带有缓冲区, 因此对带缓冲channel的发送操作在缓冲区未满, 接收操作在缓冲区非空的情况下是异步的
对一个带缓冲channel来说, 在缓冲区未满的情况下, 对它进行发送操作的goroutine并不会阻塞挂起; 在缓冲区有数据的情况下, 对它进行接收操作的goroutine也不会阻塞挂起
但是当缓冲区满了的情况下, 对它进行发送操作的goroutine就会阻塞挂起; 当缓存区为空的情况下, 对它进行接收操作的goroutine也会阻塞挂起
代码演示 c33_v2

使用操作符 <-, 我们还可以声明只发送channel类型和只接收channel类型.
试图从一个只发送channel类型变量中接收数据, 或者向一个只接收channel类型发送数据, 都会导致编译错误.
通常只发送channel类型和只接收channel类型, 都被用作函数的参数类型或返回值, 用于限制对channel内的操作, 或者是明确可对channel进行的操作的类型
ch := make(chan<- int, 1) // 只发送channel类型
ch := make(<-chan int, 1) // 只接收channel类型

如何安全的判断channel的关闭

一旦向一个已经关闭的channel执行发送操作, 这个操作就会引发panic

无缓冲channel的惯用法  ①用作信号传递 ②用于替代锁机制

go语言提倡的 不要通过共享内存的方式通信, 而是通过channel通信的方式分享数据