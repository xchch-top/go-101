## go入门

go语言的设计哲学: 简单,显式,组合,并发,面向工程.

go env https://static001.geekbang.org/resource/image/ba/96/ba6990798fb17fc18386749f9cce2c96.jpg
go help environment

go源文件总是用全小写字母形式的短小单词命名, 并且以.go扩展名结尾, 例如helloworld.go
整个go程序中仅允许有一个main包
go是一种编译型语言, 意味着, 只有你编译完go程序后, 才可以将生成的可执行文件交付与其他人, 并运行在没有安装go的环境中
go代码风格使用Tab而不是空格来实现缩进, go源码文件本身采用的是Unicode字符集, 而且用的是UTF-8标准的字符编码方式

在go 1.16版本中, go module已经成为了go默认的包依赖管理机制和go源码构建机制.
go module的核心是一个名为go.mod的文件, 文件中存储了module对第三方依赖的全部信息
go.sum记录了直接依赖和间接依赖的版本的hash, 用来校验本地包的真实性. 在构建的时候, 如果本地依赖包的hash值和go.sum中记录的不一致, 会被拒绝构建
go程序的构建过程就是确定包版本, 编译以及将编译后的目标文件链接在一起的过程
建议将项目拆分为多个仓库, 每个仓库单独一个module进行单独的版本管理和演进
golang标准项目布局 https://github.com/golang-standards/project-layout/blob/master/README.md

添加go mod文件 go mod init gitlab.xchch.top/golang-group/go-101
手动添加依赖 go get github.com/valyala/fasthttp
工具自动添加依赖 go mod tidy
go mod tidy 下载的依赖module会放在本地的module缓存路径下, 变量值为$GOPATH[0]/pkg/mod, go1.15后可以通过GOMODCACHE环境变量自定义本地module的缓存路径

go module的最小版本使用原则: A明明说只要求C v1.1.0, B明明说只要求C v1.3.0, go会在改项目依赖的所有版本中, 选出符合项目整体需求的最小版本
go团队认为最小版本选择, 为go程序实现持久的和可重现的构建提供了最佳的方案

go语言要求可执行程序的main包必须包含main函数, 否则go编译器会报错. 在启动了多个goroutine的go应用中, main.main函数将在go应用的主goroutine中执行
非main包中的go函数仅限于包内使用

对于init函数, go程序中我们不能显式的调用init, 否则会受收到编译错误
go包可以拥有不止一个init函数, 每个组成go包的go源文件中, 可以定义多个init函数.
在初始化go包的时候, go会按照一定的次序, 逐一地调用这个包的init函数, 一般来说, 先传递给go编译器的源文件中的init函数, 会先被执行, 同一个源文件中的多个init函数, 会按照声明依次执行

从程序逻辑结构角度来看, go包是程序逻辑封装的基本单元, 每个包都可以理解为是一个自治的封装良好的, 对外暴露有限接口的基本单元.
根据go语言规范, 一个被多个包依赖的包仅会被初始化了一次, 包内按照 "常量 -> 变量 -> init函数"的顺序进行初始化

init函数的第一个常用用途: 重置包级变量值. 负责对包内部以及暴露到外部的包级数据(主要是包级变量)的初始状态进行检查
init函数的第二个常用用途: 实现对包级变量的复杂初始化
init函数的第三个常用用途: 在init函数中实现"注册模式"

## 变量

go语言变量初始为类型零值
go语言类型零值 https://static001.geekbang.org/resource/image/92/23/92242134ff5ccdaed32854d01690ab23.jpg
变量声明最佳实践 https://static001.geekbang.org/resource/image/9c/77/9c663f2d88e2e53a8184669bf2338077.jpg

go语言的变量分为两类, 包级变量和局部变量
包级变量就是包级别可见的变量. 如果是导出变量, 那么这个包级变量也可以被视为全局变量
局部变量就是go函数或方法体内声明的变量, 尽在函数或方法体内可见

go语言预定义标识符 https://static001.geekbang.org/resource/image/01/95/01b8135e83c9fc39afcecdb26d4e1495.jpg
go vet工具可以用于对go源码做一系列静态检查

go语言原生支持的数值类型包含整型, 浮点型以及复数类型

## 字符串

go语言原生支持字符串类型, go语言中字符串类型为string
string类型的数据是不可变的, 不能通过下标修改字符串的字符

go字符串中的每个字符都是一个Unicode字符, 并且这些Unicode字符是以UTF-8格式存储在内存当中的.
go字符串组成的两种视角: 字节视角、字符视角
代码演示 string/c13_v1: 字符串组成的两种视角

rune本质上是int32类型的别名类型, type rune = int32
一个rune实例就是一个Unicode字符, 一个Go字符串也可以被视为rune实例的集合
utf-32编码方案固定使用4个字节表示每个Unicode字符码点
utf-8方案采用边长字节, 对Unicode字符的码点进行编码, utf-8编码使用的字节数量从1个到4个不等. 
代码演示 string/c13_v2: 使用utf8包对unicode字符(rune)进行编码

StringHeader是一个string的运行时表示
StringHeader类型其实是一个描述符, 它本身并不真正存储字符串数据, 而是仅由一个指向底层存储的指针和字符串长度字段组成的
结论: 直接将string类型通过函数/方法参数传入也不会带来太多的开销
代码演示 string/c13_v3: string内部结构剖析

go字符串常见操作
下标操作: 我们获取的是字符串中特定下标上的字节, 而不是字符
字符迭代: 常规for迭代得到的是字符串内容的字节, for range迭代得到的是字符串中unicode字符的码点值
字符串拼接: 字符串的 +/+= 操作性能不高, go还提供了strings.Builder、strings.Join、fmt.Sprintf等函数来进行字符串连接操作
字符串比较: 在字符串比较上, go采用字典序的比较策略, 分别从每个字符串的起始处, 开始逐个字节地对两个字符串类型变量进行比较, 当两个字符串之间出现了第一个不同的元素, 比较就结束了.
字符串转换: go支持字符串与字节切片, 字符串与rune切片的双向转换, 并且这种转换无需调用任何函数, 只需使用显式类型转换就可以了

代码演示 string
c13_v1: 字符串组成的两种视角
c13_v2: 使用utf8包对unicode字符(rune)进行编码
c13_v3: string内部结构剖析
c13_v4: 字符串常见操作

## 常量

go是使用var关键字声明变量的, 用const关键字来声明常量
go常量一旦被初始化后, 它的值在整个程序的生命周期内便保持不变
常量的类型只限于数值类型, 字符串类型, 以及bool类型

无类型常量
即变两个类型拥有相同的底层类型, 但他们仍然是不同的数据类型, 不可以被相互比较或混在一个表达式中进行运算
无类型常量不是说真的没有类型, 它有自己的默认类型, 默认类型是由它的初值形式来决定的

代码演示 const
c14_v1: 无类型常量

隐式转型
隐式转型说的是, 对于无类型常量参与的表达式求值, go编译器会根据上下文中的类型信息, 把无类型常量自动转换为对应的类型后, 再参与求值计算.
无类型常量与常量隐式转型的珠联璧合, 使得在go这样的具有强类型系统的语言, 在处理表达式混合数据类型运算的时候具有比较大的灵活性, 代码编写也得到了一定程度的简化.
在go中使用无类型常量是一种惯用法, 可以多多熟悉这种形式

枚举
go语言其实并没有原生提供枚举类型
go语言中, 可以使用const代码块定义的常量集合, 来实现枚举. 枚举类型本质上就是一个由有限数量常量构成的集合.
go的const语法提供了"隐式重复前一个非空表达式"的机制
iota是go语言的一个预定义的标识符, 它表示的是const声明块中每个常量所处位置在块中的偏移量(从0开始),
iota在标准库中的使用  sync/mutex.go
