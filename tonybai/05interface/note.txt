## 接口

空接口类型 interface{}
go接口类型的方法集合中放入首字母消息的非导出方法也是合法的, 在日常编码过程中, 我们极少使用这种非导出方法的接口类型
如果一个类型T的方法集合是接口类型I的方法集合的等价集合或者超级, 我们就说类型T实现了接口类型I, 那么类型T的变量就可以作为合法的右值赋值个接口类型I的变量
由于空接口类型的方法集合为空, 这意味着任何类型都实现了空接口的方法集合, 所以我们可以将任何类型的值作为右值, 赋值给空接口类型的变量

接口类型变量赋值的逆操作, 也就是通过接口类型变量还原它的右值的类型与值信息, 这个过程被称为 类型断言
类型断言的语法 v, ok := i.(T)
代码演示 c28_v1
v, ok := i.(T) 中T是一个接口类型, 那么类型断言的语义就会变成: 断言i的值实现了接口类型T
如果断言成功, 变量v的类型为i的值的类型, 而并非接口类型T
如果断言失败, v的类型信息为接口类型T, 它的值为nil

尽量定义小接口, 即方法个数在1~3个之间的接口
小接口的优势
①接口越小, 抽象程度越高, 对应的事物集合越大
②小接口易于实现和测试
③小接口表示的契约职责单一, 易于复用组合
代码演示 c28_v2

接口的静态特性体现在接口类型变量具有静态类型, 比如: var err error 中变量err的静态类型为error
接口的动态类型, 体现在接口类型变量在运行时还存储了右值的真实类型信息
代码演示 c29_v1 鸭子类型

nil接口不等于nil
代码演示 c29_v2

接口本质上是一种抽象, 它的功能是解耦, 这条规则也在告诉我们, 不要为了使用接口而使用接口
组合是go语言的重要设计哲学之一, 正交性则为组合哲学的落地提供了更为方便的条件
尽量不要使用可以逃过编译器类型安全检查的空接口类型

## workpool