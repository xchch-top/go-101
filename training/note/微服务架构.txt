# 微服务架构

## 概览

微服务架构的复杂源于网络间通信
微服务框架就是要解决这种架构下, 组件之间的发现, 通信, 容错等问题

微服务拆分方式: 按照组织架构拆分; 按照DDD的限界上下文拆分
微服务合适的粒度: 三四个人能清楚服务的细节, 即两个熟悉项目的人带两个新手

微服务框架主要问题 http://mc.xchch.top:6670/download/tech/2211/微服务框架主要问题.png
通信: 服务之间如何发起调用, 一般就是rpc, 或者是HTTP直接通信
服务治理: 涵盖从服务注册与发现到可观测性的全部内容

在底层通信协议上, 遇事不决用gRPC, 如果是小型系统, 可以考虑直接使用HTTP接口
gRPC比较学院派, 它是典型的使用IDL来生成代码的RPC框架. 是多语言通信的首选
IDL(interface description/definition language): 接口描述语言/接口定义语言. 是指用一种中间语言来定义接口, 而后为其他的语言生成对应代码的设计方案
gRPC使用的IDL是protobuf
protobuf也定义了序列化格式, 所以我们也常说使用protobuf来作为序列化协议

kratos

面试要点
微服务框架是什么? 主要就是解决两个问题, 通信和服务治理
为什么使用微服务框架? 本质上是为了分而治之, 将业务拆分之后独立治理, 部署
RPC框架和RestFul框架有什么区别? 应该说, 两者基本没联系, 全是区别. 唯一的联系, 就是RPC框架可以利用RestFul来实现.
    RestFul是指符合REST风格的HTTP接口, 而RPC指的是通过远程调用, 本质上就是两回事
RPC框架和Web框架有什么区别? 基本没什么联系, 都是区别. 唯一的共同点可以通过对web框架封装来实现RPC通信

## RPC

代码演示 rpc_v1
v0: 反射篡改方法的调用
v1: 单元测试增加返回值的校验
v2: 代码中实现response部分
v3: 单元测试代码重构
v4: 单元测试增加异常场景的用例
v5: 增加e2e测试代码
v6: 服务端处理rpc请求
v7: 客户端读取rpc的响应结果
v8: 使用reflectionStub对server代码重构

rpc执行流程总结
客户端
1. 首先反射拿到request, 核心是服务名字, 方法名字和参数
2. 将request进行编码, 要注意序列化并且加上长度字段
3. 使用连接池, 或者一个连接, 把请求发出去
4. 从连接里面读取响应, 解析成结构体
服务端
1. 启动一个服务端, 监听一个端口
2. 读取长度字段, 再根据长度, 读完整个消息
3. 解析成request
4. 查找服务, 和对应的方法
5. 构造方法对应的输入
6. 反射执行调用
7. 编码响应
8. 写回响应

面试要点
什么是rpc? 远程过程调用. 类似的还有RMI, 远程方法调用
和使用http接口比起来, 使用RPC有什么优势? 不必关心http调用的细节, 对于使用者来说就如同本地调用一般
rpc框架的要点是什么? 客户端捕捉调用信息, 编码成二进制, 发送到服务端. 服务端查找本地服务, 执行调用, 写回响应. 任何一个rpc框架都类似
rpc框架怎么捕捉本地调用信息? 主要依赖于代理模式和代码生成模式
什么是代理模式? 什么是动态代理模式? 动态代理模式可以看做是动态生成的代理, 一般指运行时生成的代理
动态代理技术能用来做什么? 四个字, 为所欲为. 在这里就是用来发起rpc调用, 然后再返回响应

## grpc协议

grpc协议分为头部和body两个部分, 因为grpc是直接基于http来实现的, 所以, grpc的头部就是放在http协议头, body就是放在http协议体里面
grpc和dubbo协议都可以看做是应用层协议, 其他协议设计也是类似的, 比如tcp协议

协议设计总结
协议一般都是分成两个部分: 协议头和协议体
协议头包含接收方"如何处理这个消息"的必要信息, 具体来说就是描述协议本身的数据, 和描述这次请求的数据
协议体则大多数情况下都是存放请求数据

从形态上来说, 协议体必然是变长的; 而协议头可以是定长的, 也可以是变长的.
在变长协议头的情况下, 需要有两个字段来描述长度, 一个描述协议头有多长, 一个描述协议体有多长

代码演示 rpc_v1
v0: 上一版本的最终代码
v1: 定义request和response的的协议头
v2: 增加encodeReq和decodeReq的测试, 完成e2e测试