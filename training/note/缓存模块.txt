# 缓存模块

## 缓存API

cache的开源组件 beego, go-cache

## 本地缓存

本地缓存 如何处理过期时间
策略一: 每一个key开一个goroutine盯着, 过期就执行删除策略
策略二: 用一个goroutine定时轮询, 找到所有过期的key, 然后删除
策略三: 啥也不干, 用户访问key的时候检查过期时间
思路: 策略二和策略三一起使用, 优势: 删除时可以控制删除的量, 只删除一部分, 同时get时, 如果key过期了, 删掉这个key
实现: 在创建cache的时候, 同时创建一个goroutine, 这个goroutine会检查每个key的过期时间, 并且在过期之后执行删除
    要点①控制住检查的间隔. 时间间隔过短, 影响用户, 资源消耗大
    要点②要控制住遍历的资源开销: 如果全部key遍历一遍, 那么可能耗时极长, 影响应用. 可以控制遍历的时长, 例如只遍历1ms, 可以控制遍历的数量, 例如只遍历100个
在get的时候, 粗暴的做法是直接加写锁, 但是也可以考虑用double-check写法

代码实现 local_cache
v0: 策略二实现
v1: 增加策略三, 优化get操作和过期检测操作
v2: 增加evict回调功能
v3: 控制本地缓存的内存

与redis对比
Redis的过期处理, 也是用的类似的策略: get的时候检查是否过期, 遍历key找出过期的删掉

控制本地缓存内存的两种策略
控制键值对数量 比如说只能允许十万个键值对
控制整体内存 需要计算每个对象的大小, 然后累加

## redis cache

mockgen使用
cd training\week11\redis_cache\v1
go install github.com/golang/mock/mockgen@1.6.0
mockgen -package mocks -destination mocks/redis_cmdable.mock.go -source C:\Users\{name}\go\pkg\mod\github.com\go-redis\redis\v9@v9.0.0-rc.1/command.go

代码实现 redis_cache
v0: local_cache的最终代码
v1: 使用mockgen+test测试redis接口的调用

面试要点
缓存过期时间怎么控制? 定期删除+懒惰删除
定期删除过期缓存有什么要注意的? 注意控制CPU的开销, 防止定期删除占用太多的资源
为什么无法做到缓存一过期就删除? 借助于延迟队列可以勉强做到, 例如在毫秒级的时间啊in误差内做到. 但是更加精确的时间误差就做不到了,
    如果没有延迟队列, 那么就只能考虑开goroutine盯着缓存键值对, 资源开销太大
本地缓存如何避免占用内存太多? 要控制内存使用量, 可以通过控制内存总量, 也可以控制键值对总数
如何提高缓存的内存利用率? 一个是不要使用Hash一类的数据结构, 另一个是不要直接存储对象, 而是存储序列化后的数据. 这个也可以看做是缓存节约内存的一部分措施