# 缓存模块

## 缓存API

cache的开源组件 beego, go-cache

## 本地缓存

本地缓存 如何处理过期时间
策略一: 每一个key开一个goroutine盯着, 过期就执行删除策略
策略二: 用一个goroutine定时轮询, 找到所有过期的key, 然后删除
策略三: 啥也不干, 用户访问key的时候检查过期时间
思路: 策略二和策略三一起使用, 优势: 删除时可以控制删除的量, 只删除一部分, 同时get时, 如果key过期了, 删掉这个key
实现: 在创建cache的时候, 同时创建一个goroutine, 这个goroutine会检查每个key的过期时间, 并且在过期之后执行删除
    要点①控制住检查的间隔. 时间间隔过短, 影响用户, 资源消耗大
    要点②要控制住遍历的资源开销: 如果全部key遍历一遍, 那么可能耗时极长, 影响应用. 可以控制遍历的时长, 例如只遍历1ms, 可以控制遍历的数量, 例如只遍历100个
在get的时候, 粗暴的做法是直接加写锁, 但是也可以考虑用double-check写法

代码实现 local_cache
v0: 策略二实现
v1: 增加策略三, 优化get操作和过期检测操作
v2: 增加evict回调功能
v3: 控制本地缓存的内存

与redis对比
Redis的过期处理, 也是用的类似的策略: get的时候检查是否过期, 遍历key找出过期的删掉

控制本地缓存内存的两种策略
控制键值对数量 比如说只能允许十万个键值对
控制整体内存 需要计算每个对象的大小, 然后累加

## redis cache

mockgen使用
cd training\week11\redis_cache\v1
go install github.com/golang/mock/mockgen@1.6.0
mockgen -package mocks -destination mocks/redis_cmdable.mock.go -source C:\Users\{name}\go\pkg\mod\github.com\go-redis\redis\v9@v9.0.0-rc.1/command.go

代码实现 redis_cache
v0: local_cache的最终代码
v1: 使用mockgen+test测试redis接口的调用
v2: 布隆过滤器代码

面试要点
缓存过期时间怎么控制? 定期删除+懒惰删除
定期删除过期缓存有什么要注意的? 注意控制CPU的开销, 防止定期删除占用太多的资源
为什么无法做到缓存一过期就删除? 借助于延迟队列可以勉强做到, 例如在毫秒级的时间啊in误差内做到. 但是更加精确的时间误差就做不到了,
    如果没有延迟队列, 那么就只能考虑开goroutine盯着缓存键值对, 资源开销太大
本地缓存如何避免占用内存太多? 要控制内存使用量, 可以通过控制内存总量, 也可以控制键值对总数
如何提高缓存的内存利用率? 一个是不要使用Hash一类的数据结构, 另一个是不要直接存储对象, 而是存储序列化后的数据. 这个也可以看做是缓存节约内存的一部分措施

缓存模式
常见的缓存模式有 cache-aside, read-through, write-through, write-back, refresh-ahead
cache-aside
    概念: 把cache当成一个普通的数据源, 更新cache和db都依赖于开发者自己写代码
    实现细节: 业务代码中可以决策 ①未命中的时候是否要从DB取数据, 如果不从DB取, 可以考虑使用默认值进行业务处理 ②同步or异步读取数据并写入 ③采用single-flight
read-through
    概念: 业务代码只需要从cache中读取数据, cache会在缓存不命中的时候取读取数据, 写数据的时候, 业务代码需要自己写db和写cache
    实现细节: cache中间件可以决策 ①未命中的时候是否要从DB取数据, 如果不从DB取, 可以考虑使用默认值进行业务处理 ②同步or异步读取数据并写入 ③采用single-flight
write-through
    概念: 开发者只需要写入cache, cache自己会更新数据库, 在读未命中缓存的情况下, 开发者需要自己去数据库捞数据, 然后更新缓存
    实现细节: cache中间件可以决策 ①同步or异步写数据到db, 或者到cache ②cache可以自由决定先写db还是先写cache, 一般是先写db
write-back
    概念: 在写操作的时候写了缓存直接返回, 不会直接更新数据库, 读也是直接读缓存, 在缓存过期的时候, 将缓存写回去数据库
          write-back主要是利用 OnEvicted 回调, 在里面将数据刷新到db里面
    优缺点: ①所有goroutine都是读写缓存, 不存在一致性的问题 ②数据可能丢失, 如果在缓存过期刷新到数据库之前, 缓存宕机, 那么会丢失数据
refresh-ahead
    refresh-ahead依赖于cdc(changed data capture)接口
    概念: 数据库暴露数据变更接口, cache或者第四方在监听到数据变更之后自动更新数据, 如果读cache未命中, 依旧要刷新缓存的话, 依然会出现并发问题

缓存异常 - ppt中的解决方案很精彩
缓存穿透
    概念: 读请求对应的数据根本不存在, 因此每次都会发起数据库查询, 数据库返回null, 所以下一次请求依旧会打到数据库
    关键点就是这个数据根本没有, 所以不会回写缓存. 一般是黑客使用了一些非法的请求, 比如说非法的邮箱, ID等
缓存击穿
    概念: 缓存中没有对应的key数据, 同时该key的访问量非常大, 大家都去数据库查询数据, 那么就可能压垮数据库
    击穿和穿透比起来, 关键在于击穿本身数据在db里面是有的, 只是缓存里面没有而已, 所以只要回写到缓存, 之后访问就是命中缓存
缓存雪崩
    概念: 同一时刻, 大量key过期, 查询都要回查数据库
    常见场景是在启动的时候加载缓存, 因为所有key的过期时间都一样, 所以会在同一时间全部过期

Single Flight
缓存异常的所有问题, 问题的落脚点都是大量请求落到了数据库上, 所以思路就是, 怎么在缓存出现问题的时候, 依旧让这些请求不会落到数据库.
single flight设计模式能够有效减轻对数据库的压力. 在有多个goroutine试图去数据库加载同一个key对应的数据时, 只允许一个goroutine过去查询, 其它都在原地等结果
热点越集中的应用, 效果越好

代码实现 cache_pattern
v0: redis_cache的最终代码
v1: read_through的版本1代码实现
v2: 使用泛型设计read_through代码
v3: v0代码上增加write_through实现
v4: v0代码上增加write_back实现