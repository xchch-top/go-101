# 缓存模块

## 缓存API

cache的开源组件 beego, go-cache

## 本地缓存

本地缓存 如何处理过期时间
策略一: 每一个key开一个goroutine盯着, 过期就执行删除策略
策略二: 用一个goroutine定时轮询, 找到所有过期的key, 然后删除
策略三: 啥也不干, 用户访问key的时候检查过期时间
思路: 策略二和策略三一起使用, 优势: 删除时可以控制删除的量, 只删除一部分, 同时get时, 如果key过期了, 删掉这个key
实现: 在创建cache的时候, 同时创建一个goroutine, 这个goroutine会检查每个key的过期时间, 并且在过期之后执行删除
    要点①控制住检查的间隔. 时间间隔过短, 影响用户, 资源消耗大
    要点②要控制住遍历的资源开销: 如果全部key遍历一遍, 那么可能耗时极长, 影响应用. 可以控制遍历的时长, 例如只遍历1ms, 可以控制遍历的数量, 例如只遍历100个
在get的时候, 粗暴的做法是直接加写锁, 但是也可以考虑用double-check写法

代码实现 local_cache
v0: 策略二实现
v1: 增加策略三, 优化get操作和过期检测操作
v2: 增加evict回调功能
v3: 控制本地缓存的内存

与redis对比
Redis的过期处理, 也是用的类似的策略: get的时候检查是否过期, 遍历key找出过期的删掉

控制本地缓存内存的两种策略
控制键值对数量 比如说只能允许十万个键值对
控制整体内存 需要计算每个对象的大小, 然后累加