# RPC

## 概览

微服务架构的复杂源于网络间通信
微服务框架就是要解决这种架构下, 组件之间的发现, 通信, 容错等问题

微服务拆分方式: 按照组织架构拆分; 按照DDD的限界上下文拆分
微服务合适的粒度: 三四个人能清楚服务的细节, 即两个熟悉项目的人带两个新手

微服务框架主要问题 http://mc.xchch.top:6670/download/tech/2211/微服务框架主要问题.png
通信: 服务之间如何发起调用, 一般就是rpc, 或者是HTTP直接通信
服务治理: 涵盖从服务注册与发现到可观测性的全部内容

在底层通信协议上, 遇事不决用gRPC, 如果是小型系统, 可以考虑直接使用HTTP接口
gRPC比较学院派, 它是典型的使用IDL来生成代码的RPC框架. 是多语言通信的首选
IDL(interface description/definition language): 接口描述语言/接口定义语言. 是指用一种中间语言来定义接口, 而后为其他的语言生成对应代码的设计方案
gRPC使用的IDL是protobuf
protobuf也定义了序列化格式, 所以我们也常说使用protobuf来作为序列化协议

kratos

面试要点
微服务框架是什么? 主要就是解决两个问题, 通信和服务治理
为什么使用微服务框架? 本质上是为了分而治之, 将业务拆分之后独立治理, 部署
RPC框架和RestFul框架有什么区别? 应该说, 两者基本没联系, 全是区别. 唯一的联系, 就是RPC框架可以利用RestFul来实现.
    RestFul是指符合REST风格的HTTP接口, 而RPC指的是通过远程调用, 本质上就是两回事
RPC框架和Web框架有什么区别? 基本没什么联系, 都是区别. 唯一的共同点可以通过对web框架封装来实现RPC通信

## RPC

代码演示 rpc_v1
v0: 反射篡改方法的调用
v1: 单元测试增加返回值的校验
v2: 代码中实现response部分
v3: 单元测试代码重构
v4: 单元测试增加异常场景的用例
v5: 增加e2e测试代码
v6: 服务端处理rpc请求
v7: 客户端读取rpc的响应结果
v8: 使用reflectionStub对server代码重构

rpc执行流程总结
客户端
1. 首先反射拿到request, 核心是服务名字, 方法名字和参数
2. 将request进行编码, 要注意序列化并且加上长度字段
3. 使用连接池, 或者一个连接, 把请求发出去
4. 从连接里面读取响应, 解析成结构体
服务端
1. 启动一个服务端, 监听一个端口
2. 读取长度字段, 再根据长度, 读完整个消息
3. 解析成request
4. 查找服务, 和对应的方法
5. 构造方法对应的输入
6. 反射执行调用
7. 编码响应
8. 写回响应

面试要点
什么是rpc? 远程过程调用. 类似的还有RMI, 远程方法调用
和使用http接口比起来, 使用RPC有什么优势? 不必关心http调用的细节, 对于使用者来说就如同本地调用一般
rpc框架的要点是什么? 客户端捕捉调用信息, 编码成二进制, 发送到服务端. 服务端查找本地服务, 执行调用, 写回响应. 任何一个rpc框架都类似
rpc框架怎么捕捉本地调用信息? 主要依赖于代理模式和代码生成模式
什么是代理模式? 什么是动态代理模式? 动态代理模式可以看做是动态生成的代理, 一般指运行时生成的代理
动态代理技术能用来做什么? 四个字, 为所欲为. 在这里就是用来发起rpc调用, 然后再返回响应

## grpc协议

grpc协议分为头部和body两个部分, 因为grpc是直接基于http来实现的, 所以, grpc的头部就是放在http协议头, body就是放在http协议体里面
grpc和dubbo协议都可以看做是应用层协议, 其他协议设计也是类似的, 比如tcp协议

协议设计总结
协议一般都是分成两个部分: 协议头和协议体
协议头包含接收方"如何处理这个消息"的必要信息, 具体来说就是描述协议本身的数据, 和描述这次请求的数据
协议体则大多数情况下都是存放请求数据

从形态上来说, 协议体必然是变长的; 而协议头可以是定长的, 也可以是变长的.
在变长协议头的情况下, 需要有两个字段来描述长度, 一个描述协议头有多长, 一个描述协议体有多长

代码演示 rpc_v2
v0: 上一版本的最终代码
v1: 定义request和response的的协议头
v2: 增加encodeReq和decodeReq的测试, 完成e2e测试
v3: 对消息体进行编解码, 完成e2e测试
v4: 对消息体使用protobuf编解码, 完成e2e测试

面试要点
RPC协议主要包含什么? 消息头和消息体
头部包含什么? 有什么用?
RPC里面为什么包含长度字段? 主要是为了切割消息, 也就是所谓的粘包问题
头部可以是变长的吗? 可以
大概描述一下gRCP协议? 关键点gRPC利用了HTTP协议, 然后再描述一下gRCP的几个常见头部
为什么尽量把元数据之类的东西放在消息头? 主要是考虑到sidecar网关之类的东西, 它们可以做到解析部分数据, 提高性能
如何在RPC协议里面支持不同序列化协议/压缩算法? 但凡问道如何在RPC协议上支持xx功能, 核心都是要在协议本身加上对应的字段.
    要考虑放到协议体或者协议头, 然后客户端和服务端都要做响应的修改

## 单向调用

rpc调用语义
异步调用: 指用户发起调用之后, 就可以去做别的事情, 而后在一段时间后再处理
单向调用(one-way): 是指用户发起调用之后, 不需要结果
回调: 用户在发起调用的时候注册一个回调, 当结果返回来之后, 用户会继续

单向调用分为真假两种
虚假的单向调用: 是指用户的请求发过去之后, 服务端会把响应发过来. 但是客户端收到响应之后会直接丢弃
真实的单向调用: 是指用户的请求发过去之后, 服务端发现是一个单向调用, 直接就不会发响应回来, 读完请求之后, 连接等资源就释放了
    核心在于: 单向调用一定是为了尽快释放两端资源的, 因此虚假的单向调用, 毫无意义

代码演示 rpc_v3
v0: 上一版本最终代码
v1: 增加oneway的代码实现, e2e测试没有通过

面试要点
什么是异步调用? go里面怎么实现? 在有goroutine的情况下, 框架设计者没有必要支持
什么是回调? go里面怎么实现? 同上
什么是one-way(单向)调用? 要注意解释真伪两种one-way的形态, 最关键在于, 服务端究竟会不会回写响应, 而后进一步讨论两种形态对于性能的影响
使用one-way有什么有点? 性能, 尽早释放资源

## 超时控制

在微服务里面, 超时控制分成两种: 单一服务超时控制和链路超时控制. 绝大多数微服务框架的超时控制都只支持单一服务超时控制
设置整个链路的超时时间, 可能是web, 可能是BFF

链路超时控制总结
1. rpc客户端需要监听cxt, 并且要把剩余超时时间传递给rpc服务端
2. rpc服务端收到请求后, 要检测元数据里面有没有携带剩余超时时间, 然后重建context.Context
3. 如果用户的业务里面用到了其他中间件, 那么用户可能需要自己手动管理超时元数据, 继续传递给其他中间件
4. 任何一个环节的超时时间, 都不可能超过链路超时时间

监听超时 http://mc.xchch.top:6670/download/tech/2211/监听超时.png
1. 理论上来讲, 超时监听可以: 只在客户端监听 或者 客户端和服务端同时监听
2. 但是不能只在服务端监听. 当服务端发现超时, 而后返回超时响应的时候, 如果网络故障, 那么客户端收不到超时响应, 因此会一直在那里等

代码演示 rpc_v4
v0: rpc_v2 v4的代码
v1: 增加超时检测的实现

完成了本地的超时控制, 现在我们需要将链路超时时间传递下去给服务端. 类似于前面的单向调用, 也是在原数据部分, 带一个key-value过去
问题? 超时时间传什么内容
1. 传递剩余超时时间, 类似于1s, 3s这种    缺点: 难以估计网络传输时间
2. 传递超时时间戳, 类似于某时某刻过期     缺点: 时间同步问题
总结: 两个方案之间, 没有特别强的优劣之分

面试要点
rpc怎么控制超时? 客户端控制, 服务端控制的特点
为什么要使用超时控制? 及时释放资源
超时时间没有设置好, 会有什么问题? 过短--大部分请求超时, 过长--浪费资源, 甚至引起goroutine
超时时间在链路中传递, 传递的是什么? 剩余超时时间或者超时时间戳. 进一步可以讨论时间戳与时间同步的问题
超时之后可以终端业务执行吗? 不可以
链路超时怎么实现? 核心就是链路中传递超时时间, 这个主要是依赖于rpc协议里传递超时时间.
    注意, 如果你是一个中间件设计者, 你还要考虑用户可能希望重置整个链路的超时时间, 那么你要设计类似的接口