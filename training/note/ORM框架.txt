# ORM框架

## ORM框架概览

ORM: 对象-关系 映射
ORM框架是帮助用户完成对象到SQL, 以及结果集到对象的映射的工具
ORM框架的主要职责: 对象 -> SQL, 结果集 -> 对象

## select起步

mysql select语句规范 https://dev.mysql.com/doc/refman/8.0/en/select.html

代码实现 orm_v1
v0: query接口定义, from部分实现
v1: where部分实现

select面试题
gorm如何构造SQL? 在GORM里面主要有四个抽象: Builder, Expression, Clause和Interface. gorm的设计思路是SQL的不同部分分开构造, 最后再拼接在一起
什么是builder模式? builder模式尤其适合用于构造复杂多变的对象
orm框架使用泛型有什么优点? 用来约束用户传入的参数或者用户希望得到的返回值, 加强类型安全

## 元数据

模型: 一般是指对应到数据库表的GO结构体定义, 也被称为schema, table等

设计总结
    模型: 对应的表名, 索引, 主键, 关联关系
    列: 列名, Go类型, 数据库类型, 是否主键, 是否外键

代码实现 orm_v2
v0: 上一版本的最终代码
v1: 反射获取元数据的表名和列名
v2: 增加errs包, 使用model对select test进行重写
v3: 增加db和registry, 缓存parseModel的结果
v4: 解析columnTag, 自定义表名

设计要点
为什么使用reflect.Type作为map的key? 理论上有三种选择 结构体名字, 表名, reflect.Type, 最终reflect.Type是唯一的选择
registry实现: registry对外只提供get方法, parseModel只在registry内部使用
registry并发安全, 使用double-check的读写锁方法
对于orm来说, 用户应该操作字段名, 生成的sql中使用的是列名, 达到解耦的效果

自定义元数据的两种方式
基于标签 见代码v4
编程方式 RegisterModel, 编程方式自定义表名和列名 -- 不重要

元数据面试题
ORM框架是怎么将一个结构体映射为一张表的? 核心就是依赖元数据, 元数据描述了两者之间的映射关系
ORM的元数据有什么用? 在构造SQL的时候, 用来将SQL映射为表; 在处理结果集的时候, 用来将表映射为Go结构体
ORM元数据一般包含什么? 表信息, 列信息, 索引信息. 在支持关联查询的时候, 还包含表之间的关联关系
    ORM表信息包含什么? 主要就是表级别上的配置, 例如表名, 如果ORM本身支持分库分表, 那么还包含分库分表信息
    ORM列信息包含什么? 主要就是列名, 类型(和对应的GO类型), 索引, 是否主键, 以及关联关系
    ORM索引信息包含什么? 主要就是每一个索引的列, 以及是否唯一
ORM如何获得模型信息? 主要是利用反射来解析go类型, 同时可以利用tag, 或者暴露编程接口, 允许用户额外定制模型(例如指定表名)
Go字段上的Tag(标签)有什么用? 用来描述字段本身的额外信息, 例如使用json来指示转化json之后的字段名称, 或者如gorm使用tag来指定列的名字, 索引
gorm是如何实现的? 只要能回答构造SQL, 处理结果集, 元数据就可以了

## select结果集处理

代码实现 orm_v3
v0: 上一版本的最终代码
v1: Get方法实现
v2: 增加单元测试用例
v3: 引入reflectValue, 重构Select的Get方法
v4: 使用creator, 引入unsafeValue

面试要点
orm框架怎么处理数据库返回的数据? 要点在于, 将列映射过去字段(借助元数据), 然后将每一列的数据解析为字段的类型(这个过程在go里面由sql包完成),
    利用反射将转化后的数据塞到结构体里. unsafe的过程则类似, 不同在于, unsafe是先在目标地址创建了字段的零值, 后面sql包把数据注入到这些地方
使用unsafe有什么有点? 性能更好
orm的性能瓶颈在哪里, 以及怎么解决? 性能瓶颈有两个: 构造SQL的过程和处理结果集. 前者主要是通过buffer pool能够极大缓解, 后者处理结果集则可以使用unsafe来加速
为什么unsafe要比反射更快? 因为反射可以看做是对unsafe的封装, 因此直接使用unsafe就相当于绕开了中间商. 绕开整个中间商之后, 同时减少了cpu消耗和内存消耗
orm框架的核心: 构造sql, 设计元数据, 处理结果集

## 指定列和聚合函数

代码实现 orm_v4
v0: 上一版本的最终代码
v1: 指定列和聚合函数
v2: 自定义select部分

面试要点
为什么where里面不能使用聚合函数? 从DB实现的角度来说, 因为聚合函数必须要在数据筛选出来之后才能计算, 也因此, 在作业里面我就说过HAVING是可以使用聚合函数的.
    简单概括就是, 在DB中处理顺序是 WHERE - GROUP BY - 聚合函数 - HAVING.
where和having的区别: 最重要的就是能不能使用聚合函数作为查询条件, 以及两者的执行顺序
聚合函数有哪些? max, min, count, sum, avg. distinct不是聚合函数
当使用聚合函数的时候, select后面有什么限制? 当使用聚合函数的时候, select后面只能是常数, 或者聚合函数, 或者出现在group by中的列. 理论上我们在org框架
    里面是可以进行这种校验的, 只是我们这个实现里面没有执行校验, 另外要小心面试官要求写SQL的时候写出这种SQL

## insert语句

代码实现 orm_v5
v0: 上一版本的最终代码
v1: 插入单行
v2: 插入多行
v3: 指定列
v4: upsert
v5: upsert2

## 方言

代码实现 orm_v6
v0: 上一版本的最终代码
v1: 方言中默认支持mysql的实现
v2: 方言实现中增加sqlite
v3: result抽象
v4: unsafe和反射两种方式读取字段 代码test没有通过

面试要点
ORM框架如何支持不同的数据库的? 一般是引入了Dialect抽象, 通过设计一个公共的接口, 为不同的数据库提供了不同的实现.
    这些实现核心都是构造SQL, 因为数据库驱动已经屏蔽了不同数据库返回结果集的差异
ORM框架在插入的时候如何处理主键? ORM如果知道主键是一个自增主键(或者TIDB)的随机主键, 并且这个主键是零值, 那么插入的时候会忽略主键列
unsafe读取字段, 如何计算偏移量? 我们课程上直接使用反射. 但是在组合的情况下, 一个组合结构体字段的偏移量等于组合结构体的起始偏移量 +该字段的偏移量

## 事务

在orm的语境下, 一般代表一个上下文, 也可以理解为一种分组机制, 在这个分组内所有的查询会共享一些基本的配置

代码实现 orm_v7
v0: 上一版本的最终代码
v1: 使用session抽象对之前代码重构

面试要点
什么是事务扩散? 在go里面怎么解决? 本质就是上下文里面有事务就用事务, 没有事务就开新事务.
    go里面解决的话只能依赖于context.Context, 基本上在别的语言里面用thread-local解决的, 到go里面都是用context.Context
事务扩散中, 如果没有开启事务应该怎么办? 看你的业务, 可以选择报错, 可以选择开启新事务, 也可以无事务运行
事务重复提交会怎么样? 在ORM层面上, 有些orm里面会维护一个标记位, 标记一个事务有没有被提交, 即便没有这个标记位, 数据库也会返回错误
go里面实现一个事务闭包要考虑一些什么问题, 如何实现? 主要是考虑panic的问题, 而后要在panic的时候, 以及业务代码返回error的时候, 回滚事务

## AOP方案

代码实现 orm_v7
v0: 上一版本的最终代码
v1: 定义middleware
v2: 打印日志案例
v3: 使用aop完成sql的mock操作

面试要点
设计模式类: 如何在go里面使用责任链模式, 怎么使用洋葱模式, 怎么使用装饰器模式
GORM的Hook设计原理: gorm的hook按照sql类型分类, 例如BeforeCreate之类, 本质上只是GORM的研发者在内部找准地方, 调用用户注册的hook
怎么监控慢查询? 可以使用aop方案, 写一个AOP的实现, 里面计算SQL执行时间, 当SQL执行的事件超过阈值的时候就可以告警或者打印出来.
    但是所有SQL监控都要注意不要把敏感数据打印出来