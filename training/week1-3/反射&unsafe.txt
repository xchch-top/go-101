# 反射&unsafe

# go反射

在go反射里面, 一个实例可以看成两部分: 值 实际类型
反射相关的api都在reflect包, 最核心的两个
    reflect.Value: 用于操作值, 部分值可以被反射修改
    reflect.Type: 用于操作类信息, 类信息是只能读取
reflect.Type可以通过reflect.Value得到, 但是反过来则不行
反射能够拿到私有字段的类型信息, 但是拿不到值

Kind
反射包有一个很强的假设: 你知道你操作的是什么Kind
Kind是一个枚举值, 用来判断操作的对应类型, 例如是否是指针, 是否是数组, 是否是切片等
所以reflect的方法, 如果你调用得不对, 它直接就panic
NumField、NumIn、NumOut 三个方法都有对应的Kind必须是什么, 否则panic

用反射设置值
可以用反射修改一个字段的值, 需要注意的是, 修改字段的值之前一定要先检查CanSet.
简单来说, 就是必须使用结构体指针, 那么结构体的字段才是可以修改的

代码演示
用反射输出字段名字和值
用反射设置值
输出方法信息并执行调用

注意事项
以结构体作为输入, 那么只能访问到结构体作为接收器的方法
以指针作为输入, 那么能访问到任何接收器的方法
输入的第一个参数, 永远都是接收器本身

反射编程小技巧
时刻注意你闲杂操作的类型是不是指针, 指针和指针指向的对象在反射层面上是两个东西
没有足够的测试就不要用反射, 因为反射API充斥着panic
切片和数组在反射上是两个东西. 方法类型的字段和方法在反射上也是两个不同的东西

面试要点
什么是反射? 反射可以看做是对对象和对类型的描述, 而我们可以通过反射来间接操作对象
能不能通过反射修改方法? 不能, go runtime没有暴露接口
什么样的字段可以被反射修改? 有一个方法CanSet可以判断, 简单来说就是addressable

## unsafe

go对齐规则
按照字长对齐: 因为go本身每一次访问内存都是按照字长的倍数来访问的
    在32位字长机器上, 就是按照4个字节对齐
    在64位字长机器上, 就是按照8个字节对齐

unsafe.Pointer 是go层面的指针, GC会维护unsafe.Pointer的值. 使用unsafe.Pointer保存对象的起始地址, 如果发生了gc, unsafe.Pointer会被GC修正, 指向新的地址
uintptr: 直接就是一个数字, 代表的是一个内存地址. 使用uintptr保存对象的起始地址, 如果发生了gc, 原本的代码会直接崩溃

unsafe面试点
uintprt和unsafe.Pointer的区别: 前者代表的是一个具体的地址, 后者代表的是一个逻辑上的指针, 后者在GC等情况下, go runtime会帮你调整, 使其永远指向真实存放对象的地址
怎么计算对象地址: 对象的起始地址是通过反射来获取, 对象内部字段的地址是通过 起始地址+字段偏移量 来计算
unsafe为什么比反射高效: 反射帮我们封装了很多unsafe的操作, 所以我们直接使用unsafe绕开了这种封装的开销. 有点像是我们不用ORM框架, 而是直接自己写SQL执行查询